---
alwaysApply: false
description: how to deploy
---
### Monitoring-only deployment (safe via ArgoCD)

Use this when deploying changes to the monitoring stack (Grafana, Prometheus, Loki, Promtail) without touching application workloads.

#### Relevant files
- Dashboards: [helm/monitoring/templates/configmap-grafana-dashboards.yaml](mdc:helm/monitoring/templates/configmap-grafana-dashboards.yaml)
- Prometheus config/alerts: [helm/monitoring/templates/configmap-prometheus.yaml](mdc:helm/monitoring/templates/configmap-prometheus.yaml)
- Grafana deployment: [helm/monitoring/templates/deployment-grafana.yaml](mdc:helm/monitoring/templates/deployment-grafana.yaml)
- ArgoCD app: [argo/echo-monitoring-prod.yaml](mdc:argo/echo-monitoring-prod.yaml)

#### Steps
1) Commit and push monitoring changes to the deployment branch (e.g. `feature/monitoring_prod`)
```bash
git add -A && git commit -m "monitoring: <summary>" && git push
```

2) Ensure ArgoCD Application points to that branch
- Confirm `.spec.source.targetRevision` is your branch in `echo-monitoring-prod`.

3) Safe sync options (avoid disruption)
```bash
kubectl -n argocd annotate application/echo-monitoring-prod \
  argocd.argoproj.io/sync-options="Validate=false,Prune=false,ApplyOutOfSyncOnly=true" --overwrite
```

4) Manually trigger sync (no prune, apply only out-of-sync)
```bash
kubectl -n argocd patch application echo-monitoring-prod --type=merge -p '{
  "operation": {
    "sync": {
      "revision": "feature/monitoring_prod",
      "prune": false,
      "dryRun": false,
      "syncStrategy": {"apply": {"force": false}}
    }
  }
}'
```

5) Monitor rollout closely (isolate to monitoring)
- Prometheus
```bash
kubectl -n monitoring rollout status deploy/prometheus --timeout=180s
```
- Grafana (PVC multi-attach can require Recreate strategy)
```bash
kubectl -n monitoring rollout status deploy/grafana --timeout=180s
# If blocked, ensure deployment strategy is Recreate in
# [helm/monitoring/templates/deployment-grafana.yaml](mdc:helm/monitoring/templates/deployment-grafana.yaml)
# then:
kubectl -n monitoring rollout restart deploy/grafana
kubectl -n monitoring rollout status deploy/grafana --timeout=180s
```

6) Validate in Grafana (no hotfix drift)
- Dashboards provisioned from ConfigMap should appear/reload. If a dashboard is missing, verify the live ConfigMap keys:
```bash
kubectl -n monitoring get configmap grafana-dashboards-config -o json | jq -r '.data | keys[]'
```

#### Guardrails
- Do not prune during sync.
- Apply only out-of-sync changes.
- Avoid replacing or restarting app workloads; only monitoring components should roll.
- Use ArgoCD-driven changes only (no manual edits in-cluster).

---

### Testing Environment Deployment

Use this workflow for deploying to the testing environment via the automated CI/CD pipeline.

#### Overview
- Testing deploys automatically from `testing` branch in echo repo
- CI/CD handles: build → test → deploy → validate
- Manual interventions should be rare

#### Standard Workflow (Recommended)

1. Create feature branch and PR to `testing`:
```bash
cd echo
git checkout testing
git pull
git checkout -b feature/my-feature
# Make changes
git push -u origin feature/my-feature
# Create PR to testing branch on GitHub
```

2. PR checks run automatically:
- Linting (ruff)
- Type checking (mypy)
- Unit tests (pytest)
- Build validation

3. On success, PR auto-merges to testing

4. Deployment pipeline runs:
- Builds Docker images
- Tags as `<commit-sha>` and `testing`
- Updates gitops repo
- ArgoCD deploys
- Smoke tests run
- Slack notification sent

#### Manual Deployment (Emergency Only)

If you need to bypass the PR process:

```bash
cd echo
git checkout testing
# Make urgent fix
git commit -am "fix: urgent issue"
git push origin testing
# Deployment triggers automatically
```

#### Monitoring Deployment

Check GitHub Actions:
- PR workflow: Validation before merge
- Deploy workflow: Build, deploy, test

Check ArgoCD:
```bash
kubectl get application -n argocd echo-testing
```

Check Slack:
- #alerts-devops will receive deployment notifications

#### Rollback

If tests fail or issues detected:

**Option 1: Revert commit** (cleanest)
```bash
cd echo-gitops
git revert HEAD
git push origin main
```

**Option 2: Manual imageTag update**
```bash
cd echo-gitops
# Edit helm/echo/values-testing.yaml
# Change imageTag to previous working version
git add helm/echo/values-testing.yaml
git commit -m "Rollback testing to <previous-sha>"
git push origin main
```

#### Debugging

**Check pod status:**
```bash
kubectl --context=do-ams3-dbr-echo-testing-k8s-cluster \
  get pods -n echo-testing
```

**Check logs:**
```bash
kubectl logs -n echo-testing deployment/echo-api-server -f
```

**Check tests:**
```bash
# Go to GitHub Actions
# Find Deploy to Testing workflow
# Check smoke-tests job
```

#### Guardrails
- All changes must pass tests before deploying
- Smoke tests validate critical functionality post-deployment
- Failed tests trigger Slack alerts with rollback instructions
- Testing environment mirrors prod/dev architecture
